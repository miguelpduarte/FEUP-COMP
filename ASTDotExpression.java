/* Generated By:JJTree: Do not edit this line. ASTDotExpression.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.ArrayList;

public class ASTDotExpression extends SimpleNode implements Typed {
  private VariableType type;

  public ASTDotExpression(int id) {
    super(id);
  }

  public ASTDotExpression(JMMParser p, int id) {
    super(p, id);
  }

  @Override
  public String getNodeName() {
    return ".";
  }

  @Override
  public VariableType getType() {
    return type;
  }

  @Override
  protected void applySemanticAnalysis() throws SemanticError {
    Node lhs_raw = children[0];

    if (!(lhs_raw instanceof ASTIdentifier || 
          lhs_raw instanceof ASTNewExpression || 
          lhs_raw instanceof ASTThis || 
          lhs_raw instanceof ASTDotExpression)) {
      throw new SemanticError(this.line, "Left hand side of dot operator is neither an Identifier, new Expression, 'this' nor a method call!");
    }

    VariableType lhs = ((Typed) lhs_raw).getType();
    if (lhs.isIgnored()) {
      this.type = new VariableType(VariableType.ignored_type);
      return;
    }

    if (children[1] instanceof ASTLength) {
      if (lhs.isIntArray()) {
        this.type = new VariableType("int");
        return;
      } else {
        throw new SemanticError(this.line, String.format("Calling .length on a non-array expression (found %s).", lhs));
      }
    }

    if (!lhs.isIdentifier()) {
      throw new SemanticError(this.line, String.format("Method call on a non class instance (found %s).", lhs));
    }
    if (!lhs.equals(JMMParser.class_type)) {
      // The type of the left-hand side is not of a know class, assumming that it's correct
      this.type = new VariableType(VariableType.ignored_type);
      return;
    }

    // Verifying the method via name and arguments
    ASTMethodCall method_call = (ASTMethodCall) children[1];
    int n_args = method_call.jjtGetNumChildren();
    ArrayList<VariableType> arg_types = new ArrayList<>();
    for (int i = 0; i < n_args; ++i) {
      arg_types.add(((Typed) method_call.jjtGetChild(i)).getType());
    }
    final String method_id = SymbolTableScopes.calculateMethodIdentifier(new VariableIdentifier(method_call.getIdentifier()), arg_types.toArray(new VariableType[0]));

    final Method m = SymbolTableScopes.getInstance().isMethodDeclared(method_id);

    if (m == null) {
      throw new SemanticError(this.line, String.format("Method with signature '%s' not found!", method_id));
    }

    this.type = m.getReturn();
  }

  @Override
  protected void generateCodeNodeClose(StringBuilder sb) {
    if (children[1] instanceof ASTLength) {
      // TODO: Make length work, ignoring for now
      return;
    }

    // invokevirtual - non static
    // invokestatic - static
    
    VariableType lhs_vt = ((Typed) children[0]).getType();
    
    if (lhs_vt.isIgnored()) {
      // static method invocation
      ASTMethodCall method_call = (ASTMethodCall) children[1];
      String method_name = method_call.getIdentifier();
      sb.append("\tinvokestatic ").append(lhs_vt.getReferencedClass())
        .append("/").append(method_name);
        
      // Method signature
      sb.append("(");

      int n_args = method_call.jjtGetNumChildren();
      for (int i = 0; i < n_args; ++i) {
        sb.append(((Typed) method_call.jjtGetChild(i)).getType().toJasminType());
      }

      // Assuming void for static methods
      sb.append(")V");

      sb.append("\n");
    } else if (lhs_vt.isIdentifier()) {
      // non-static method invocation
      ASTMethodCall method_call = (ASTMethodCall) children[1];
      String method_name = method_call.getIdentifier();
      sb.append("\tinvokevirtual ").append(lhs_vt)
        .append("/").append(method_name);
        
      // Method signature
      sb.append("(");

      int n_args = method_call.jjtGetNumChildren();
      ArrayList<VariableType> arg_types = new ArrayList<>();
      for (int i = 0; i < n_args; ++i) {
        VariableType arg_type = ((Typed) method_call.jjtGetChild(i)).getType();
        arg_types.add(arg_type);

        sb.append(arg_type.toJasminType());
      }

      sb.append(")");

      final String method_id = SymbolTableScopes.calculateMethodIdentifier(new VariableIdentifier(method_name), arg_types.toArray(new VariableType[0]));
      final Method m = SymbolTableScopes.getInstance().isMethodDeclared(method_id);
      if (m == null) {
        // Assuming void for non-declared instance methods
        sb.append("V");
      } else {
        sb.append(m.getReturn().toJasminType());
      }

      sb.append("\n");
    }
  }
}
/* JavaCC - OriginalChecksum=9e551656e978f3b2ea8f9c6934c8e272 (do not edit this line) */
