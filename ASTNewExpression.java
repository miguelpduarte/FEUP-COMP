/* Generated By:JJTree: Do not edit this line. ASTNewExpression.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTNewExpression extends SimpleNode implements Typed {
  public ASTNewExpression(int id) {
    super(id);
  }

  public ASTNewExpression(JMMParser p, int id) {
    super(p, id);
  }

  @Override
  public String getNodeName() {
    return "new";
  }

  @Override
  public VariableType getType() {
    // first child is type, second is expression for the allocation of array (if not an array, there is only one child)
    ASTType type = (ASTType) children[0];
    return new VariableType(type);
  }

  @Override
  protected void calculateStackImpact() {
    VariableType type = new VariableType((ASTType) children[0]);
    if (type.isIntArray()) {
      // pop: array size, push: arrayref
      // MethodStackSizeScopes.getInstance().getMethodScope(this.scope_identifier).impactStack(0);
      return;
    }

    MethodStackSizeScopes.getInstance().getMethodScope(this.scope_identifier).impactStack(1);
  }

  @Override
  protected void generateCodeNodeClose(StringBuilder sb) {
    VariableType type = new VariableType((ASTType) children[0]);
    if (type.isIntArray()) {
      // No need to calculate the value of the expression that is the argument of the allocation because that will be done by the generated code
      sb.append("\tnewarray int\n");
      return;
    }

    // If it is not an int[] then it is an object (only these types can be allocated using 'new')

    sb.append("\tnew ").append(type).append("\n");
    sb.append("\tdup\n"); // Saving the local reference to not lose it when invoking the constructor
    sb.append("\tinvokespecial ").append(type).append("/<init>()V\n");
  }
}
/* JavaCC - OriginalChecksum=1c5d1c8675be9c00e49865921bb77fe8 (do not edit this line) */
