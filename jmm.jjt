PARSER_BEGIN(JMMParser)

// código Java que invoca o parser
public class JMMParser {
    public static void main(String args[]) throws ParseException {
        // criação do objecto utilizando o constructor com argumento para
        // ler do standard input (teclado)
        JMMParser parser = new JMMParser(System.in);
        parser.Program();
    }
}

PARSER_END(JMMParser)

SKIP :
{
    " " | "\t" | "\r" | "\n"
}

TOKEN :
{
      <Integer: ("-")? (<Digit>)+>
    | <#Digit: ["0" - "9"]>
    | <Operation: ("&&" | "<" | "+" | "-" | "*" | "/") >

    | <TypeInt: "int" >
    | <TypeBoolean: "boolean" >
    | <TypeString: "String" >
    | <Class: "class" >
    | <Generalization: "extends" >
    | <Public: "public" >
    | <Static: "static" >
    | <Void: "void" >
    | <Main: "main" >
    | <Return: "return" >
    | <Length: "length" >
    | <True: "true" >
    | <False: "false" >
    | <This: "this" >
    | <New: "new" >
    | <If: "if" >
    | <Else: "else" >
    | <While: "while" >

    | <Identifier: <FullAlpha> (<FullAlpha> | <Digit>)* >
    | <#FullAlpha: (<Alpha> | "_" | "$") >
    | <#Alpha: (<LowerCase> | <UpperCase>) >
    | <#LowerCase: ["a"-"z"] >
    | <#UpperCase: ["A"-"Z"] >

    | <BlockStart: "{" >
    | <BlockEnd: "}" >
    | <ParenthesisStart: "(" >
    | <ParenthesisEnd: ")" >
    | <ArrayStart: "[" >
    | <ArrayEnd: "]" >    
    | <Semicolon: ";" >
    | <Comma: "," >
    | <Dot: "." >
    | <ExclamationMark: "!" >
    | <Equals: "=" >

}

void Program() : {} {
    /* (
          ClassDeclaration()
        | VarDeclaration()
    ) */
    Expression()
    <EOF>
}

void VarDeclaration() : {} {
    Type() <Identifier> <Semicolon>
}

void ClassDeclaration() : {} {
    <Class> <Identifier> (ClassGeneralization())? 
    <BlockStart>
        ClassBody()
    <BlockEnd>
}

void ClassGeneralization() : {} {
    <Generalization> <Identifier>
}

void ClassBody() : {} {
    (VarDeclaration())*
    (<Public> (MainDeclaration() | MethodDeclaration()))*
}

void Type() : {} {
    (
          (<TypeInt> (Array())? )
        | <TypeBoolean>
        | <Identifier>
    )
}

void Array() : {} {
    <ArrayStart> <ArrayEnd>
}

void MainDeclaration() : {} {
    <Static> <Void> <Main> <ParenthesisStart> <TypeString> Array() <Identifier> <ParenthesisEnd>
    <BlockStart>
        (VarDeclaration())*
        //STATEMENT GOES HERE
    <BlockEnd>
}

void MethodDeclaration() : {} {
    Type() <Identifier> <ParenthesisStart> (Arguments())? <ParenthesisEnd>
    <BlockStart>
        (VarDeclaration())*
        //STATEMENT GOES HERE
        <Return> /*EXPRESSION GOES HERE*/ <Semicolon>
    <BlockEnd>
}

void Arguments() : {} {
    Type() <Identifier> (<Comma> Type() <Identifier>)*
}

void Expression() : {} {
    (
        //   (Expression() <Operation> Expression())
        // | (Expression() <ArrayStart> Expression() <ArrayEnd>)
        // | (Expression() <Dot> <Length>)
        // | (Expression() <Dot> <Identifier> <ParenthesisStart> (ExpressionList())? <ParenthesisEnd>)
          <Integer> // TODO CHECK INTEGET LITERAL
        | <True> 
        | <False>
        | <Identifier>
        | <This>
        | ExpressionNew()
        | (<ExclamationMark> Expression())
        | (<ParenthesisStart> Expression() <ParenthesisEnd>)
    )
    ExpressionLinha()
}

void ExpressionLinha() : {} {
      (<Operation> Expression() ExpressionLinha())
    | (<ArrayStart> Expression() <ArrayEnd> ExpressionLinha())
    | (ExpressionDot() ExpressionLinha())
    | {}
}

void ExpressionNew() : {} {
    <New> 
    ( 
          (<TypeInt> <ArrayStart> Expression() <ArrayEnd>)
        | (<Identifier> <ParenthesisStart> <ParenthesisEnd>)
    )
}

void ExpressionDot() : {} {
    <Dot>
    (
        (<Length>)
      | (<Identifier> <ParenthesisStart> (ExpressionList())? <ParenthesisEnd>)
    )
}

void ExpressionList() : {} {
    Expression() (<Comma> Expression())*
}

void Statement() : {} {
    (
          (<BlockStart> Statement() <BlockEnd>)
        | (<If> <ParenthesisStart> Expression() <ParenthesisEnd> Statement() <Else> Statement())
        | (<While> <ParenthesisStart> Expression() <ParenthesisEnd> Statement())
        | (Expression() <Semicolon>)
        | (IdentifierStatement())
    )    
}

void IdentifierStatement() : {} {
    <Identifier>
    (
          (<Equals> Expression() <Semicolon>)
        | (<ArrayStart> Expression() <ArrayEnd> <Equals> Expression() <Semicolon>)
    )
}