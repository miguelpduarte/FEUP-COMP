/* Generated By:JJTree: Do not edit this line. ASTAssignmentStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAssignmentStatement extends SimpleNode implements Supressable {
  /**
   * If the assignment was supressed due to optimizations (Constant Propagation for example)
   */
  protected boolean is_supressed = false;

  public ASTAssignmentStatement(int id) {
    super(id);
  }

  public ASTAssignmentStatement(JMMParser p, int id) {
    super(p, id);
  }

  @Override
  public String getNodeName() {
    return "=";
  }

  @Override
  protected void applySemanticAnalysis() throws SemanticError {
    Node lhs_raw = children[0];
    if (!(lhs_raw instanceof ASTIdentifier || lhs_raw instanceof ASTArrayAccessExpression)) {
      throw new SemanticError(this.line, "Invalid left hand side of assignment (neither an identifier nor array access)");
    }

    VariableType lhs = ((Typed) lhs_raw).getType();
    VariableType rhs = ((Typed) children[1]).getType();

    if (!lhs.equals(rhs) && !(lhs.isIdentifier() && rhs.isIdentifier())){
      throw new SemanticError(this.line, String.format("Invalid assignment between types %s and %s", lhs, rhs));
    }

    if (lhs_raw instanceof ASTIdentifier) {
      ((ASTIdentifier) lhs_raw).getVariable().markAsInitialized();
    }
  }

  @Override
  protected void calculateStackImpactNodeOpen() {
    Node lhs_raw = children[0];
    if (lhs_raw instanceof ASTIdentifier) {
      // Storing the left hand side of an assignment
      Variable lhs = ((ASTIdentifier) lhs_raw).getVariable();
      if (lhs.isClassField()) {
        MethodStackSizeScopes.getInstance().getMethodScope(this.scope_identifier).impactStack(1);
      }
    }
  }

  @Override
  protected void calculateStackImpact() {
    Node lhs_raw = children[0];
    if (lhs_raw instanceof ASTIdentifier) {
      // Storing the left hand side of an assignment
      MethodStackSizeScopes.getInstance().getMethodScope(this.scope_identifier).impactStack(-1);
    } else if (lhs_raw instanceof ASTArrayAccessExpression) {
      // Storing the current operands that are in the stack in the given array (arrayref, index, value)
      // These values need not be calculated or loaded because such will already be done by the child nodes
      MethodStackSizeScopes.getInstance().getMethodScope(this.scope_identifier).impactStack(-3);
    }
  }

  /**
   * Tests if a node is the left hand side of this assignment
   * @param n Node to test
   * @return True if the node is the LHS of the assignment, false otherwise
   */
  public boolean isLHS(Node n) {
    return n == children[0];
  }

  @Override
  protected void applyOptimizations() {
    if (!(children[0] instanceof ASTIdentifier)) {
      // This optimization can only be applied to identifiers, not arrays
      return;
    }
    // The variables are already marked with the correct number of initializations (done in semantic analysis)
    Variable lhs_var = ((ASTIdentifier) children[0]).getVariable();
    Node rhs = children[1];

    if (lhs_var.wasNotReinitialized() && rhs instanceof ASTIntegerLiteral) {
      String integer_value = ((ASTIntegerLiteral) rhs).getValue();
      lhs_var.setConstantValue(integer_value);
      JMMParser.n_propagated_variables++;
      this.is_supressed = true;
    }
  }

  @Override
  public boolean isSupressed() {
    return this.is_supressed || this.iincable_info.is_iincable;
  }

  @Override
  protected void generateCodeNodeOpen(StringBuilder sb) {
    this.isIincAble();

    Node lhs_raw = children[0];
    if (lhs_raw instanceof ASTIdentifier) {
      // Storing the left hand side of an assignment
      Variable lhs = ((ASTIdentifier) lhs_raw).getVariable();
      if (lhs.isClassField()) {
        sb.append("\taload_0\n");
      }
    }
  }

  @Override
  protected void generateCodeNodeClose(StringBuilder sb) {
    if (this.is_supressed) {
      // If the assignment was supressed then no code needs to be generated
      return;
    }

    if (this.iincable_info.is_iincable) {
      sb.append("\tiinc ").append(this.iincable_info.variable.getLocalVarIndex()).append(" ").append(this.iincable_info.value).append("\n");

      return;
    }

    Node lhs_raw = children[0];
    if (lhs_raw instanceof ASTIdentifier) {
      // Storing the left hand side of an assignment
      Variable lhs = ((ASTIdentifier) lhs_raw).getVariable();

      sb.append(lhs.toJasminStore());
    } else if (lhs_raw instanceof ASTArrayAccessExpression) {
      // Storing the current operands that are in the stack in the given array (arrayref, index, value)
      // These values need not be calculated or loaded because such will already be done by the child nodes
      sb.append("\tiastore\n");
    }
  }

  private IincAbleInformation iincable_info = new IincAbleInformation();

  /**
   * Tests if it is possible to use `iinc` instead of another value storing instruction (for higher efficiency)
   */
  public void isIincAble() {
    if (!(children[0] instanceof ASTIdentifier) || !(children[1] instanceof ASTArithmeticExpression)) {
      return;
    }

    Variable lhs_var = ((ASTIdentifier) children[0]).getVariable();
    if (lhs_var.isClassField()) {
      // Cannot use iinc on a class field
      return;
    }
    ASTArithmeticExpression rhs = (ASTArithmeticExpression) children[1];

    this.iincable_info = rhs.isIincAble(lhs_var);
  }

  public VariableType getLHSVarType() {
    return ((Typed) children[0]).getType();
  }
}
/* JavaCC - OriginalChecksum=f503663119aadd748782d6739471f263 (do not edit this line) */
